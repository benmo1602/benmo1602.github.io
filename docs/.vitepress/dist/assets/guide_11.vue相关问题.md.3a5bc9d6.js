import{o as e,c as n,d as t}from"./app.6013c500.js";const r='{"title":"Vue","description":"","frontmatter":{},"headers":[{"level":3,"title":"Vue","slug":"vue"}],"relativePath":"guide/11.vue相关问题.md","lastUpdated":1624091523429}',a={},p=t('<h3 id="vue"><a class="header-anchor" href="#vue" aria-hidden="true">#</a> Vue</h3><p>​ new Vue</p><div class="language-"><pre><code>初始化生命周期、 事件、data、props、watch、computed， 通过Object.defineProprety 设置 setter、 getter 函数实现响应式 以及 依赖收集；\n\n初始化之后 调用$mount进行组件挂载\n\ntemplate 需要编译、 render ， function不需要编译\n\nvue2 编译\n\nparse  =&gt; AST、\noptimize =&gt; 标记 static 静态节点（在update时， diff 算法的 path 会直接 跳过 静态static 节点提升性能）、\ngenerate  （AST） =&gt; render function  （字符串、 staticRenderFns）\n在经历过 `parse`、`optimize` 与 `generate` 这三个阶段以后，组件中就会存在渲染 VNode 所需的 render function 了。\n\nrender function 在渲染时 会读取所需要的值， 触发getter 进行依赖收集，\n依赖收集 将观察者 watcher 对象 存放到 当前闭包的 Dep订阅者的 subs中\n触发setter时候 ， setter 通知之前的依赖收集得到 Dep 中的subs （订阅）多个watcher ， 触发notify （发布） 通知每一个subs 的watcher 更新视图， watcher =&gt; update , 触发 patch 经过 diff算法  （双指针, 纵向对比）\n</code></pre></div><p>VNode</p><div class="language-"><pre><code>节点有更多的属性来标志节点，比如 isStatic （代表是否为静态节点）、 isComment （代表是否为注释节点）等。\n</code></pre></div><ol><li><p>vue的双向数据绑定实现原理</p><div class="language-"><pre><code>采用数据劫持和发布者-订阅者模式\n数据劫持是利用ES5的Object.defineProperty(obj,key,val)方法来劫持每个属性的getter和setter，在数据变动是发布消息给订阅者，从而触发相应的回调来更新视图，下面来一步步实现。\n\n基于 object.defineProperty 定义 setter， getter\nproxy\n</code></pre></div></li><li><p>观察者模式 vs 发布-订阅模式</p><div class="language-"><pre><code>watcher 是在render funtion  在渲染的时候 触出发getter 进行依赖收集\n\n依赖收集 将watcher 对象放入 Dep订阅的subs中 （订阅），\n\n当时出发setter 的时候， setter  通知 之前进行依赖收集的Dep 的subs （订阅）多个watcher 出发 notify（发布）\n\n通知每一个 subs 的watcher 更新视图\n\nwatcher =&gt; update 触发 patch 更过diff 算法 （双指针， 纵向对比）然后更新VNode\n</code></pre></div></li><li><p>对于 MVVM 理解的</p><div class="language-"><pre><code>什么是MVC\n\nMVC 是 Model-View-Controller 的缩写，即 模型—视图—控制器 。\nModel：后端传递的 数据 。\nView：所看到的 页面 。\nController：页面 业务逻辑 。\nMVC是 单向通信 。即View和Model，必须通过Controller来承上启下。\n使用MVC的 目的 就是 将M和V的代码分离 。\nMVC和MVVM的关系\n\nMVVM是将之前的MVC后端开发：\n\nM：model数据库中的数据\nV：view前端页面\nC：controller后端控制器\n中的V即View分成了MVVM模式\n\nMVVM模式：不需要用户手动的操作dom的，主要是实现数据双向绑定\n\n[扩展问题]：VUE和MVVM的关系\n\nVue.js 可以说是MVVM 架构的最佳实践，VUE并没有完全遵循MVVM，专注于 MVVM 中的 ViewModel，不仅做到了数据双向绑定，而且也是一款相对比较轻量级的JS 库，API 简洁，很容易上手\n欢迎留言~~~\n</code></pre></div></li><li><p>vue的数据双向绑定原理</p><p>​</p><div class="language-"><pre><code>Object.defineProperty\n</code></pre></div></li><li><p>vue封装组件</p></li><li><p>vue-router实现原理，为什么要选vue，与其它框架对比的优势和劣势</p><p>​</p></li><li><p>vuex是用来做什么的，vue源码结构</p></li><li><p>组件的通讯方式</p><div class="language-js"><pre><code>props<span class="token operator">/</span> $emit\n$emit<span class="token operator">/</span>$on\nvuex\n$attrs<span class="token operator">/</span>$listeners  可以在 props 控制接收#attrs\nprovide<span class="token operator">/</span>inject  实现响应式 <span class="token number">2.6</span>版本 使用observable\n$parent <span class="token operator">/</span> $children与 ref\n</code></pre></div></li></ol>',6);a.render=function(t,r,a,s,o,i){return e(),n("div",null,[p])};export default a;export{r as __pageData};
