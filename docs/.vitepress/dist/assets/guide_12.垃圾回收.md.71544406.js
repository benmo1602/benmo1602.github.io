import{o as e,c as r,d as a}from"./app.8f4d3ffd.js";const d='{"title":"内存生命周期","description":"","frontmatter":{},"headers":[{"level":3,"title":"内存生命周期","slug":"内存生命周期"},{"level":3,"title":"内存释放","slug":"内存释放"},{"level":3,"title":"多个运行时互相通信","slug":"多个运行时互相通信"},{"level":2,"title":"永不阻塞","slug":"永不阻塞"}],"relativePath":"guide/12.垃圾回收.md","lastUpdated":1623379326112}',o={},h=a('<p>关于内存回收</p><h3 id="内存生命周期"><a class="header-anchor" href="#内存生命周期" aria-hidden="true">#</a> 内存生命周期</h3><h4 id="js-内存分配"><a class="header-anchor" href="#js-内存分配" aria-hidden="true">#</a> js 内存分配</h4><ol><li><p>声明</p></li><li><p>函数调用</p><div class="language-"><pre><code>使用值 实际上是对 数据的 读取 写入操作 \n</code></pre></div></li></ol><h3 id="内存释放"><a class="header-anchor" href="#内存释放" aria-hidden="true">#</a> 内存释放</h3><h4 id="垃圾回收"><a class="header-anchor" href="#垃圾回收" aria-hidden="true">#</a> 垃圾回收</h4><h5 id="引用计数-垃圾收集"><a class="header-anchor" href="#引用计数-垃圾收集" aria-hidden="true">#</a> 引用计数 垃圾收集</h5><p>​ 限制 ：循环引用</p><h5 id="标记-清除算法"><a class="header-anchor" href="#标记-清除算法" aria-hidden="true">#</a> 标记-清除算法</h5><p>从对象是否被需要， 到数据是否还可以获得</p><div class="language-"><pre><code>从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。\n</code></pre></div><h3 id="多个运行时互相通信"><a class="header-anchor" href="#多个运行时互相通信" aria-hidden="true">#</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop#%E5%A4%9A%E4%B8%AA%E8%BF%90%E8%A1%8C%E6%97%B6%E4%BA%92%E7%9B%B8%E9%80%9A%E4%BF%A1" target="_blank" rel="noopener noreferrer">多个运行时互相通信</a></h3><p>一个 web worker 或者一个跨域的 <code>iframe</code> 都有自己的栈、堆和消息队列。两个不同的运行时只能通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage" target="_blank" rel="noopener noreferrer"><code>postMessage</code></a> 方法进行通信。如果另一个运行时侦听 <code>message</code> 事件，则此方法会向该运行时添加消息。</p><h2 id="永不阻塞"><a class="header-anchor" href="#永不阻塞" aria-hidden="true">#</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop#%E6%B0%B8%E4%B8%8D%E9%98%BB%E5%A1%9E" target="_blank" rel="noopener noreferrer">永不阻塞</a></h2><p>JavaScript的事件循环模型与许多其他语言不同的一个非常有趣的特性是，它永不阻塞。 处理 I/O 通常通过事件和回调来执行，所以当一个应用正等待一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API" target="_blank" rel="noopener noreferrer">IndexedDB</a> 查询返回或者一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener noreferrer">XHR</a> 请求返回时，它仍然可以处理其它事情，比如用户输入。</p>',15);o.render=function(a,d,o,l,t,i){return e(),r("div",null,[h])};export default o;export{d as __pageData};
