import{o as n,c as a,d as s}from"./app.8f4d3ffd.js";const t='{"title":"es6","description":"","frontmatter":{},"headers":[{"level":3,"title":"es6","slug":"es6"}],"relativePath":"guide/20.es6.md","lastUpdated":1623742755936}',e={},p=s('<h3 id="es6"><a class="header-anchor" href="#es6" aria-hidden="true">#</a> es6</h3><ul><li><h4 id="var-let-和-const-的用法和区别"><a class="header-anchor" href="#var-let-和-const-的用法和区别" aria-hidden="true">#</a> var let 和 const 的用法和区别</h4><ul><li>作用域上区别 、let const 块作用域</li><li>const 不允许 在被赋值</li><li>let 、const 不会挂到window上 ， 而别 不存在变量提升</li></ul></li><li><h4 id="修饰器"><a class="header-anchor" href="#修饰器" aria-hidden="true">#</a> 修饰器</h4></li><li><h4 id="箭头函数：-arguments对象"><a class="header-anchor" href="#箭头函数：-arguments对象" aria-hidden="true">#</a> 箭头函数： arguments对象</h4><div class="language-js"><pre><code>箭头函数表达式的语法比函数表达式更简洁，并且没有自己的<span class="token keyword">this</span>，arguments，<span class="token keyword">super</span>或<span class="token keyword">new</span><span class="token punctuation">.</span>target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。\n引入箭头函数有两个方面的作用：更简短的函数并且不绑定<span class="token keyword">this</span>。\n不绑定arguments\n</code></pre></div><p>​</p><div class="language-"><pre><code>\n使用 new 操作符 // 报错 consttructor \n使用 prototype 属性 // undefined \n使用 yield 关键词  // \n\n</code></pre></div></li><li><h4 id="for-of-、-for-in-、-for-await-of"><a class="header-anchor" href="#for-of-、-for-in-、-for-await-of" aria-hidden="true">#</a> for of 、 for in 、 for await of</h4><div class="language-"><pre><code>for...of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句\n\n</code></pre></div></li><li><h4 id="import-和require的方式的区别-es6的方式和commonjs的模式"><a class="header-anchor" href="#import-和require的方式的区别-es6的方式和commonjs的模式" aria-hidden="true">#</a> import 和require的方式的区别 (es6的方式和commonJs的模式)</h4><div class="language-"><pre><code>IIFE立即执行函数\n\ncommomJs  require  （node 默认方式）\n\nAMD (异步加载)、CMD（同步加载） 记载方式 \n\nES Module  .cjs .mjs\n</code></pre></div></li><li><h4 id="promise的用法-内部实现原理"><a class="header-anchor" href="#promise的用法-内部实现原理" aria-hidden="true">#</a> <a href="https://zhuanlan.zhihu.com/p/58428287" target="_blank" rel="noopener noreferrer">promise的用法, 内部实现原理</a></h4><p>Promise 也还是使用回调函数，只不过是把回调封装在了内部，使用上一直通过 then 方法的链式调用，使得多层的回调嵌套看起来变成了同一层的，书写上以及理解上会更直观和简洁一些。</p><div class="language-js"><pre><code><span class="token comment">//极简的实现</span>\n<span class="token keyword">class</span> <span class="token class-name">Promise</span> <span class="token punctuation">{</span>\n    callbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">fn</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_resolve</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">onFulfilled</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>callbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>onFulfilled<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token function">_resolve</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>callbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">fn</span> <span class="token operator">=&gt;</span> <span class="token function">fn</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">//Promise应用</span>\n<span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;done&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&#39;5秒&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">tip</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>tip<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div></li><li><h4 id="对async、await的理解，内部原理"><a class="header-anchor" href="#对async、await的理解，内部原理" aria-hidden="true">#</a> 对async、await的理解，内部原理</h4><p>async 是Generator函数的语法糖，并对Generator函数进行了改进</p><ul><li>async的实现就是将Generator 函数和自动执行器，包装在一个函数里。</li><li>更好的语义</li><li>更广的适用性</li><li>返回值是Promise</li></ul></li><li><h4 id="generrator"><a class="header-anchor" href="#generrator" aria-hidden="true">#</a> <a href="https://juejin.cn/post/6844903902849007624" target="_blank" rel="noopener noreferrer">generrator</a></h4><div class="language-"><pre><code>// Generator函数语法：重点是*和关键字yield\nfunction* helloWorldGenerator() {\n  yield &#39;hello&#39;;\n  yield &#39;world&#39;;\n  return &#39;ending&#39;;\n}\nvar hw = helloWorldGenerator();\n</code></pre></div><p>协程是一种程序运行的方式，可以用单线程实现，也可以用多线程实现。</p><ul><li>协程与普通线程的差异:</li></ul><ol><li><p>普通线程是抢先式的，会争夺cpu资源，而协程是合作的，</p></li><li><p>next 同一时间，可以有多个普通线程运行，而协程则只有一个在运行，其他协程则处在暂停状态。</p></li></ol><ul><li><h4 id="for-in-和-for-of"><a class="header-anchor" href="#for-in-和-for-of" aria-hidden="true">#</a> for in 和 for of</h4><div class="language-"><pre><code>for..of （es6）\n\t适用遍历数/数组对象/字符串/map/set等拥有迭代器对象的集合.但是不能遍历对象,因为没有迭代器对象； \n\t它可以正确响应break、continue 和 return语句\n如果你想迭代一个对象的属性，你可以用for-in\n</code></pre></div></li></ul></li></ul>',2);e.render=function(s,t,e,o,c,l){return n(),a("div",null,[p])};export default e;export{t as __pageData};
