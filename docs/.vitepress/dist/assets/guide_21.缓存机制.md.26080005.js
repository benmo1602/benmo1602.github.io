import{o as e,c as a,d as c}from"./app.6013c500.js";const r='{"title":"缓存位置","description":"","frontmatter":{},"headers":[{"level":2,"title":"缓存位置","slug":"缓存位置"},{"level":3,"title":"频繁变动的资源 使用过 cache-control : no-cache","slug":"频繁变动的资源-使用过-cache-control-no-cache"},{"level":3,"title":"不常变化的资源  Cache-Control: max-age=31536000","slug":"不常变化的资源-cache-control-max-age-31536000"},{"level":2,"title":"用户行为对浏览器缓存的影响","slug":"用户行为对浏览器缓存的影响"},{"level":2,"title":"","slug":""}],"relativePath":"guide/21.缓存机制.md","lastUpdated":1623748665457}',o={},n=c('<p>浏览器的缓存机制，如何缓存，和缓存的优先级</p><h2 id="缓存位置"><a class="header-anchor" href="#缓存位置" aria-hidden="true">#</a> 缓存位置</h2><ul><li><p>Service Worker</p><div class="language-"><pre><code>使用 Service Worker的话，传输协议必须为 HTTPS\n首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。\n</code></pre></div></li><li><p>Memory Cache</p></li><li><div class="language-"><pre><code>Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。\npreloader的相关指令已经是页面优化的常见手段之一，它可以一边解析js/css文件，一边网络请求下一个资源。\n\n需要注意的事情是，内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。\n\n</code></pre></div></li><li><p>Disk Cache</p><p>​</p><div class="language-"><pre><code>绝大部分的缓存都来自 Disk Cache，关于 HTTP 的协议头中的缓存字段，我们会在下文进行详细介绍。\n\n浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？\n关于这点，网上说法不一，不过以下观点比较靠得住：\n\n对于大文件来说，大概率是不存储在内存中的，反之优先\n当前系统内存使用率高的话，文件优先存储进硬盘\n\n</code></pre></div></li><li><p>Push Cache</p><div class="language-"><pre><code>Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。\n</code></pre></div></li></ul><p><strong>通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的</strong>。</p><ul><li>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</li><li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</li></ul><p>强缓存</p><div class="language-"><pre><code>不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。、\n\n​\t强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。\nExpires=max-age +    HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效\n在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。\n当Cache-Control:max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。\n\n</code></pre></div><p>协商缓存</p><p><strong>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</strong></p><div class="language-"><pre><code>- 协商缓存生效，返回304和Not Modified\n- 协商缓存失效，返回200和请求结果\n协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。\nLast-Modified 设置失效时间  304 ， 京都市已秒为单位 \nEtag值放到request header里的If-None-Match里 ， 对比发现文件变化 才会返回新文件\n\n首先在精确度上，Etag要优于Last-Modified。\nLast-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。\n第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。\n第三在优先级上，服务器校验优先考虑Etag\n\n</code></pre></div><p>文件缓存 和 接口缓存的区别关系</p><h3 id="频繁变动的资源-使用过-cache-control-no-cache"><a class="header-anchor" href="#频繁变动的资源-使用过-cache-control-no-cache" aria-hidden="true">#</a> 频繁变动的资源 使用过 cache-control : no-cache</h3><h3 id="不常变化的资源-cache-control-max-age-31536000"><a class="header-anchor" href="#不常变化的资源-cache-control-max-age-31536000" aria-hidden="true">#</a> 不常变化的资源 Cache-Control: max-age=31536000</h3><h2 id="用户行为对浏览器缓存的影响"><a class="header-anchor" href="#用户行为对浏览器缓存的影响" aria-hidden="true">#</a> 用户行为对浏览器缓存的影响</h2><p>打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。</p><p>普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。</p><p>强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 <code>Cache-control: no-cache</code>(为了兼容，还带了 <code>Pragma: no-cache</code>),服务器直接返回 200 和最新内容。</p><p>参考文章：</p><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228395&amp;idx=1&amp;sn=dcf7e3bd518f1e189ce17eaed94c27bb&amp;chksm=bd49516f8a3ed879221bf28bf68ac00c4733a6048c54ea90e75a9e2315a262c2d66fb29a4a34&amp;mpshare=1&amp;scene=1&amp;srcid=0419jU32MPcOkcBWJJVdgj2J#rd" target="_blank" rel="noopener noreferrer">彻底理解浏览器的缓存机制</a></p><h2 id=""><a class="header-anchor" href="#" aria-hidden="true">#</a></h2>',20);o.render=function(c,r,o,d,i,l){return e(),a("div",null,[n])};export default o;export{r as __pageData};
