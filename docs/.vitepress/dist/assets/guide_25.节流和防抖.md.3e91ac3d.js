import{o as n,c as s,d as a}from"./app.6013c500.js";const t='{"title":"防抖","description":"","frontmatter":{},"headers":[{"level":3,"title":"防抖","slug":"防抖"}],"relativePath":"guide/25.节流和防抖.md","lastUpdated":1623740829473}',p={},o=a('<h3 id="防抖"><a class="header-anchor" href="#防抖" aria-hidden="true">#</a> 防抖</h3><p>基于上述场景，首先提出第一种思路：<strong>在第一次触发事件时，不立即执行函数，而是给出一个期限值比如200ms</strong>，然后：</p><ul><li>如果在200ms内没有再次触发滚动事件，那么就执行函数</li><li>如果在200ms内再次触发滚动事件，那么当前的计时取消，重新开始计时</li></ul><p><strong>效果</strong>：如果短时间内大量触发同一事件，只会执行一次函数。</p><p><strong>实现</strong>：既然前面都提到了计时，那实现的关键就在于<code>setTimeout</code>这个函数，由于还需要一个变量来保存计时，考虑维护全局纯净，可以借助闭包来实现：</p><div class="language-js"><pre><code><span class="token comment">/*\n* fn [function] 需要防抖的函数\n* delay [number] 毫秒，防抖期限值\n*/</span>\n<span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span>delay</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment">//借助闭包</span>\n    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">{</span>\n            <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span> \n          \t<span class="token comment">//进入该分支语句，说明当前正在一个计时过程中，并且又触发了相同事件。所以要取消当前的计时，重新开始计时</span>\n            timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span>delay<span class="token punctuation">)</span> \n        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>\n            timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span>delay<span class="token punctuation">)</span> <span class="token comment">// 进入该分支说明当前并没有在计时，那么就开始一个计时</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n</code></pre></div><h4 id="节流"><a class="header-anchor" href="#节流" aria-hidden="true">#</a> 节流</h4><p>我们可以设计一种<strong>类似控制阀门一样定期开放的函数，也就是让函数执行一次后，在某个时间段内暂时失效，过了这段时间后再重新激活</strong>（类似于技能冷却时间）。</p><p><strong>效果</strong>：如果短时间内大量触发同一事件，那么<strong>在函数执行一次之后，该函数在指定的时间期限内不再工作</strong>，直至过了这段时间才重新生效。</p><p><strong>实现</strong> 这里借助<code>setTimeout</code>来做一个简单的实现，加上一个状态位<code>valid</code>来表示当前函数是否处于工作状态：</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span>delay</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">let</span> valid <span class="token operator">=</span> <span class="token boolean">true</span>\n    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n       <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>valid<span class="token punctuation">)</span><span class="token punctuation">{</span>\n           <span class="token keyword">return</span> <span class="token boolean">false</span>  <span class="token comment">//休息时间 暂不接客</span>\n       <span class="token punctuation">}</span>\n       <span class="token comment">// 工作时间，执行函数并且在间隔期内把状态位设为无效</span>\n        valid <span class="token operator">=</span> <span class="token boolean">false</span>\n        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n            <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n            valid <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token comment">/* 请注意，节流函数并不止上面这种实现方案,\n   例如可以完全不借助setTimeout，可以把状态位换成时间戳，然后利用时间戳差值是否大于指定间隔时间来做判定。\n   也可以直接将setTimeout的返回的标记当做判断条件-判断当前定时器是否存在，如果存在表示还在冷却，并且在执行fn之后消除定时器表示激活，原理都一样\n    */</span>\n</code></pre></div>',11);p.render=function(a,t,p,e,c,l){return n(),s("div",null,[o])};export default p;export{t as __pageData};
